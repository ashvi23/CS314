<!DOCTYPE html>
<link href="https://fonts.googleapis.com/css?family=Cardo|Dancing+Script|Inconsolata|Lato|Raleway" rel="stylesheet">
<style>
    #demobox {
      background-color: #cfc ;
      padding: 10px ;
      border: 1px solid green ;
    }
    table,th,td {
  		margin: 40px;
        border: 1px solid black;
  		border-collapse: collapse;
        width: 500px;
        padding:5px;
        
    }
   
	#codebox{
      background-color: #D9F6D9;
      padding: 5px;
      width: 600px;
      border: 1.3px solid green;
      margin: 40px;
	}
	
	code{
		font-family:monospace;
	}
	h1{
    	 font-family: 'Dancing Script', Georgia, Times, serif;
         font-size: 59px;
         line-height: 60px;
         text-shadow: 4px 4px 4px #aaa;
         margin:10px;
    }
    h2{
    	font-family: 'Raleway', sans-serif;
        font-size:21px;
    }
    p1{
     font-family: 'Cardo', Georgia, Times, serif;
     font-size: 15px;
     line-height: 20px;
     }
    p2{
     font-family: 'Cardo', Georgia, Times, serif;
     font-size: 23px;
     line-height: 20px;
     }
    p3{
     font-family: 'Lato', sans-serif;
     font-size: 17px;
     line-height: 20px;
    }
    p4{
   
    font-family: 'Inconsolata', monospace;
    font-size:13px;
    line-height: 15px;
    }
    
</style>

<style type = "text/css">
			<!--
			.tab {margin-left: 30px;}
			-->
			
			<!--
			.tab2 {margin-left: 60px;}
			-->
            <!--
			.tab3 {margin-left: 80px;}
			-->
          
</style>


<html>
	<body>
    	
		<div class= "Stacks">
		
		
			<h1><center>Stacks</center></h1>
			<p1 class="tab"> The following stacks are implemented using Last In First Out (LIFO) method. LIFO means that the element inserted most recently or the one at "the top of the stack," will be the first element to be deleted. This is data structure that can be thought of as linear. There are a few operations that can be performed on this data structure. In this tutorial, we have implemented inserting (push), deleting (pop), viewing (peek) and checking if the stack contains elements (isEmpty). There are many ways to implement this structure, but we have defined our own stack and implemented corresponding methods. <br/></p1>
			
            <h2> <p2 class="tab">  Python:</br></p2></h2>
			
			<div id="codebox">
            <pre>
			<p class="tab"> <code>  
class Stack:
	def __init__(self):
		self.stack = []
	
	def push(self, data):
		self.stack.append(data)
		
	def pop(self, data):
		temp = self.stack.pop()
		return temp
		
	def peek(self):
		if stack:
			return stack[-1] 
		else:
			return None
		
	def isEmpty(self):
		if self.stack == []:
			return True
		else:
			return False
            </code>
			</pre>
			
			</div>
			
			<p3 class="tab"> Big O Analysis:</p3>
				<p class = "tab2"> Push: O(1)<br/>
                <p class = "tab3"> Push involves appending a piece of data at the top of the stack. Because you are not sorting the stack or accessing any elements inside the stack, the Big O is O(1).<br/>
				<p class = "tab2"> Pop: O(1)<br/>
                <p class = "tab3"> Pop accesses the most recent element of the stack which is at the front. Since it is only dealing with the top most element, the big O is O(1).<br/>
				<p class = "tab2"> Peek: O(1) <br/>
                <p class = "tab3"> In peek, the algorithm implemented checks if the stack has elements/exists and if it does then it returns the last added element. In this algorithm, at most two operations happen, checking if the stack exists, and returning the element, and both of these operations occur in O(1) time because the amount of elements in the stack have no impact on the runtime of the function.  <br/>
                <p class = "tab2"> isEmpty: O(1) <br/>
                <p class = "tab3"> isEmpty finds out whether the stack is empty or not by checking if there are one or more elements in the stack. To do this, it must "peek" at the stack. Since the operation time is independent of the number of elements of the stack, the big O is O(1).<br/><br/></p>
			
		 <h2> <p2 class="tab">  Racket:</br></p2></h2>
			
			<div id="codebox">
            <pre>
			<p class="tab"> 
            <code> 
#lang racket

(define my-stack '(1 2 3 4 5 6 7))

(define (printstack)
(define (printhelper  my-stack)
  (if (empty?) '()
      (display my-stack)))
  (printhelper  my-stack))

(define (pop)
 (define (pop-helper my-stack)
  
   (set!  my-stack (cdr  my-stack))
   )
 (pop-helper my-stack))

(define (push x)
(define (push-helper x  my-stack)
  (set!  my-stack (cons x  my-stack)))
(push-helper x my-stack))

(define (empty?)
 (define (empty-helper  my-stack)
   (if (null?  my-stack) #t
      #f))
  (empty-helper my-stack))
            </code>
            </pre>
            </p>
			</div>
			
			<p3 class="tab"> Big O Analysis:</p3>
				<p class = "tab2"> Push: O(1)<br/>
                <p class = "tab3"> For push, the new element is being added to the front of the list using Cons. Since, we are not traversing the stack in order to find a place to insert the element, like we might in a link list, the Big O is 1. The access time and operation time for each push is constant and independent of the length of the stack. <br/>
				<p class = "tab2"> Pop: O(1)<br/>
                <p class = "tab3"> This implementation of pop uses cdr on the stack. Since this is only accessing the first element, the big O is O(1).<br/>
				<p class = "tab2"> Peek: O(1) <br/>
                <p class = "tab3"> In peek(), the access time is also O(1) because you only have to car the first element of the list. Accessing the top most element is a one time operation that is independent of the number of elements in the list. <br/>
                <p class = "tab2"> isEmpty: O(1) <br/>
                <p class = "tab3"> Is Empty is also O(1) because once again, you only have to access the stack once. If when the stack is accessed, there is an element inside that means the stack is not empty, otherwise, the stack is empty.<br/><br/></p>
			
		 <h2> <p2 class="tab">  Haskell:</br></p2></h2>
			
			<div id="codebox">
            <pre>
			<p class="tab"> <code>
import Data.List
import Data.Bool

data MyStack a = MyStack [a] deriving (Show, Eq)

myPush :: a -> MyStack a -> MyStack a
myPush b (MyStack xs) =  MyStack(b:xs)

myPop ::  MyStack a -> MyStack a
myPop (MyStack xs) = if length xs == 0 
			then error "Empty Stack" else MyStack(tail xs)

myPeek:: MyStack a -> a
myPeek (MyStack (x:xs)) = if length xs == 0 
			then error "Empty Stack" else x

myIsEmpty :: MyStack a -> Bool
myIsEmpty (MyStack xs) = if length xs == 0 
			then True else False
           	</code>
            </pre>
			</div>
			
			<p3 class="tab"> Big O Analysis:</p3>
				<p class = "tab2"> Push: O(1)<br/>
                <p class = "tab3"> Haskell's implementation of push is also O(1). In order to add to the stack, we simply need to concatnate the new element using ":". No matter what is provided as an input, the push algorith will still take the same amount of time. Using ":" results in one operation, and therefore, the Big O is O(1). <br/>
				<p class = "tab2"> Pop: O(1)<br/>
                <p class = "tab3"> In order to pop an element of the stack, we simply have to remove the element thats on the top of the stack. If a stack looks like [2,19,45,21,7,5], applying the pop function to it would result in a new stack that looks like [19,45,21,7,5]. The actual values and input of the stack has no impact on the operation time, because we are only deleting the first element of the stack. This makes pop another function that has a Big O of 1.  <br/>
				<p class = "tab2"> Peek: O(1) <br/>
                <p class = "tab3"> In peek, the first element/top of the stack is accessed. What the element actually is does not matter. Since the operation is happening to the first element and the operation time remains the same despite the number of elements in the stack, the Big O is O(1) <br/>
                <p class = "tab2"> isEmpty: O(1) <br/>
                <p class = "tab3"> isEmpty is a bool function that checks whether or not the stack has elements in it. In order to check if a stack is empty, the function only needs to chek the topmost element because if it has atleast one or more element, then the stack is not exmpty. Because of this, the big O is O(1). The access time is constant for the same reason as it is peek().<br/><br/></p>
			
		
			
            <p2 class="tab">At a Glance</p2>
           <p3><table>
            <tr bgcolor = #D3D3D3>
              
              <th>Methods</th>
              <th>Python</th>
              <th>Racket</th>
              <th>Haskell</th>
            </tr>
            <tr>
              <td>Push</td>
              <td>O(1)</td>
              <td>O(1)</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>Pop</td>
              <td>O(1)</td>
              <td>O(1)</td>
              <td>O(1)</td>
            </tr>
            <tr>
            <td>Peek</td>
              <td>O(1)</td>
              <td>O(1)</td>
              <td>O(1)</td>
            </tr>
            <tr>
            <td>isEmpty</td>
              <td>O(1)</td>
              <td>O(1)</td>
              <td>O(1)</td>
            </tr>
          </table>

            </p3>
            
            

			<p2 class="tab"> Functional vs Imperative</p2>
			<p class="tab"> In this case, both functional (Haskell, Racket) and imperative (Python) languages implement stacks with the same Big O. Since the Big O are the same, in order to compare which language fits best with stacks, we would have to consider the actual elements of the language. Both Haskell and Racket are great when working with lists, and stacks can be thought of a version of lists. In this sense, performing any comprehensions on stack, haskell would provide the best results. However, generally with stacks, there is not much to do besides accessing the topmost element. We must consider however, both Haskell and Racket have immutable variabes and lists. This may be a hinderance during application because stacks are a constantly changing structure. In haskell, new variable names would have to be created each time there is a change to the structure. In racket, there is a similar issue, but, by using set!, the variables can be set to a different value. Another aspect to consider when comparing the languages is ease of implementation. All three languages were very simple when it came to implementation. All three languages are concise and easy to read when it comes to implementing stacks.<br/><br/></p>
			<p2 class="tab">Static vs Dynamic</p2>
			<p class="tab"> A static language binds a name to a type and object, whereas a dynamic laguage names are only bound to and object. Haskell, is a statically typed language and made implementing stacks very easy. With Haskell, there is a guarantee that the elements pushed will be of the same type. There wasn't an issue in decalring what type to make the stack because I was able to declare it as [a]. This allowed me to create a stack of Ints, Strings, Chars etc with only this implementation. Python, a dynamically typed language, also made implementing stacks very easy. There was no need to worry if a particular type will work with the declared functions, since the language does not bind to types. Both of the languages have the same Big O of O(1), which means, deciding which language is better suited for stacks comes down to the use of the stack. If the stack is being used to store various types of data, python would be a better fit. <br/></p>
            <p4 class="tab"> View More DS:<a href="/Queues">Queues</a>, <a href="/Linkedlist"> Linklist</a>, <a href="/BST"> Binary Search Tree</a><br/>
             <p4 class= "tab"><a href="/#"> Back to Main </a> </p4>
		</div>
	</body>
</html>

