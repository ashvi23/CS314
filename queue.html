<!DOCTYPE html>
<link href="https://fonts.googleapis.com/css?family=Cardo|Dancing+Script|Inconsolata|Lato|Raleway" rel="stylesheet">
<style>
    #demobox {
      background-color: #cfc ;
      padding: 10px ;
      border: 1px solid green ;
    }
    table,th,td {
  		margin: 40px;
        border: 1px solid black;
  		border-collapse: collapse;
        width: 500px;
        padding:5px;
        
    }
   
	#codebox{
      background-color: #D9F6D9;
      padding: 5px;
      width: 600px;
      border: 1.3px solid green;
      margin: 40px;
	}
	
	code{
		font-family:monospace;
	}
	h1{
    	 font-family: 'Dancing Script', Georgia, Times, serif;
         font-size: 59px;
         line-height: 60px;
         text-shadow: 4px 4px 4px #aaa;
         margin:10px;
    }
    h2{
    	font-family: 'Raleway', sans-serif;
        font-size:21px;
    }
    p1{
     font-family: 'Cardo', Georgia, Times, serif;
     font-size: 15px;
     line-height: 20px;
     }
    p2{
     font-family: 'Cardo', Georgia, Times, serif;
     font-size: 23px;
     line-height: 20px;
     }
    p3{
     font-family: 'Lato', sans-serif;
     font-size: 17px;
     line-height: 20px;
    }
    p4{
   
    font-family: 'Inconsolata', monospace;
    font-size:13px;
    line-height: 15px;
    }
    
</style>

<style type = "text/css">
			<!--
			.tab {margin-left: 30px;}
			-->
			
			<!--
			.tab2 {margin-left: 60px;}
			-->
            <!--
			.tab3 {margin-left: 80px;}
			-->
          
</style>


<html>
	<body>
    	
		<div class= "Queues">
		
		
			<h1><center>Queues<center/></h1>
			<p1 class="tab">Queues are a great abstract data structure. The queues implemented below use a FIFO approach to programming. FIFO is First In First Out, which means that the element that was entered first is the first one to exit the queue, and the newest element that entered the queue is the last one to exit. This approach, much like the name suggests, is similar to a queue or a line. The below image from geeksforgeeks illustrates the concept extremely well. In this tutorial, we implement enqueue (insertion), dequeue (deletion), peek (view first element), and isEmpty. We have created our own queue class/data type and corresponding functions. <br/> </p1>
			<p class ="tab"> <img src="https://media.geeksforgeeks.org/wp-content/uploads/FIFO.jpg" alt="FIFO approach illustration"> </p>
            <h2> <p2 class="tab">  Python:</br></p2></h2>
			
			<div id="codebox">
            <pre>
			<p class="tab"> <code>  
#Queue Implmentation

#Queue class
class Queue:
	def __init__(self):
		self.queue = []
		
	def enqueue(self, data):
		self.queue.insert(0, data)
		
	def dequeue(self, data):
		temp = self.queue.pop()
		return temp
		
	def peek(self):
		if queue:
			return queue[-1] 
		else:
			return None	
			
	def isEmpty(self):
		if self.queue == []:
			return True
		else:
			return False
	

            </code>
			</pre>
			
			</div>
			
			<p3 class="tab"> Big O Analysis:</p3>
				<p class = "tab2"> Enqueue: O(1)<br/>
                <p class = "tab3"> In our Python implementation, the queue is a simple python list (a predefined type) that's had predefined methods wrapped up for it within a Class. The enqueue method consists of a wrapper for ".insert", which already exists as a list method, and is of complexity O(1).<br/>
				<p class = "tab2"> Dequeue: O(1)<br/>
                <p class = "tab3"> A similar situation applies to dequeue as does to enqueue, the dequeue method is simply ".pop" (O(1)) enrobed in a new method.<br/>
				<p class = "tab2"> Peek: O(1) <br/>
                <p class = "tab3"> Peek simply indexes the queue from the right, using negative integers as is Python's syntax. Indexing takes (O(1)) time.<br/>
                <p class = "tab2"> isEmpty: O(1) <br/>
                <p class = "tab3"> isEmpty checks if the current queue is equivalent to the empty list, and returns the corresponding boolean (O(1)). <br/><br/></p>
			
		 <h2> <p2 class="tab">  Racket:</br></p2></h2>
			
			<div id="codebox">
            <pre>
			<p class="tab"> 
            <code> 
#lang racket

(define my-q '())

(define (printq)
(define (printhelper)
  (if (empty?) '()
      (display my-q)))
  (printhelper))

(define (dequeue)
 (define (dequeue-helper)
   (if (null? my-q) (set!  my-q '())
   (set!  my-q (reverse (cdr (reverse my-q)))))
   )
 (dequeue-helper))

(define (enqueue x)
(define (enqueue-helper x)
  (set!  my-q (cons x  my-q)))
(enqueue-helper x))

(define (isEmpty)
 (define (isEmpty-helper)
   (if (null?  my-q) #t
      #f))
  (isEmpty-helper))

(define (peek)
  (last my-q))
            </code>
            </pre>
            </p>
			</div>
			
			<p3 class="tab"> Big O Analysis:</p3>
				<p class = "tab2"> Enqueue: O(1)<br/>
                <p class = "tab3"> We use "cons" once to add to the beginning of the list, which takes O(1) time. <br/>
				<p class = "tab2"> Dequeue: O(n)<br/>
                <p class = "tab3"> In Racket, lists, which is what the queue was coded in, are implementions of singly linked lists. In order to access the end (in this framework, technically the front), one must traverse to each position before it. In a list of n nodes, this means it takes O(n) time. This particular code uses the reverse function, which has O(n) time complexity, to access the last node, and then uses car to pop said last value off of the end (O(1)), finally restoring it to its original order using reverse (O(n)).<br/>
				<p class = "tab2"> Peek: O(n) <br/>
                <p class = "tab3"> As mentioned before, accessing the last node of a list takes O(n) time, even using the in-built function last, which the given peek function is simply a wrapper for.<br/>
                <p class = "tab2"> isEmpty: O(1) <br/>
                <p class = "tab3"> Simply using the "null?" procedure (O(1)) once lets us know if our list contains any values.<br/><br/></p>
			
		 <h2> <p2 class="tab">  Haskell:</br></p2></h2>
			
			<div id="codebox">
            <pre>
			<p class="tab"> <code>
import Data.List
import Data.Bool
data MyQueue a = MyQueue [a]
	deriving (Show, Eq)

myEnqueue :: a -> MyQueue a -> MyQueue a
myEnqueue b (MyQueue xs) =  MyQueue(xs ++[b])

myDequeue ::  MyQueue a -> MyQueue a
myDequeue (MyQueue xs) = if length xs == 0 
		then error "Empty Stack" else MyQueue(tail xs)

myIsEmpty :: MyQueue a -> Bool
myIsEmpty (MyQueue xs) = if length xs == 0 
		then True else False

myPeek:: MyQueue a -> a
myPeek (MyQueue (x:xs)) = if length xs == 0 
		then error "Empty Stack" else x
           	</code>
            </pre>
			</div>
			
			<p3 class="tab"> Big O Analysis:</p3>
				<p class = "tab2"> Enqueue: O(1)<br/>
                <p class = "tab3"> As in the previous two languages, the queue implemented in Haskell is a list that has been wrapped to be it's own Haskell data type. Enqueue is done using append on the given queue, which takes only O(1) time.<br/>
				<p class = "tab2"> Dequeue: O(1)<br/>
                <p class = "tab3"> Dequeue is done by taking the "tail" of the queue (aka list), in the case that the list isn't empty, which only has to be done once, hence it has O(1) complexity.<br/>
				<p class = "tab2"> Peek: O(1) <br/>
                <p class = "tab3"> Peek uses pattern matching to remove the first item from the list and return it, in O(1) time.<br/>
                <p class = "tab2"> isEmpty: O(1) <br/>
                <p class = "tab3"> isEmpty applies the length function to the queue and returns true if its length evaluates to one, and false otherwise. This is done a single time, so it's complexity is O(1).<br/><br/></p>
			
		
			
            <p2 class="tab">At a Glance</p2>
           <p3><table>
            <tr bgcolor = #D3D3D3>
              
              <th>Methods</th>
              <th>Python</th>
              <th>Racket</th>
              <th>Haskell</th>
            </tr>
            <tr>
              <td>Enqueue</td>
              <td>O(1)</td>
              <td>O(1)</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>Dequeue</td>
              <td>O(1)</td>
              <td>O(n)</td>
              <td>O(1)</td>
            </tr>
            <tr>
            <td>Peek</td>
              <td>O(1)</td>
              <td>O(n)</td>
              <td>O(1)</td>
            </tr>
            <tr>
            <td>isEmpty</td>
              <td>O(1)</td>
              <td>O(1)</td>
              <td>O(1)</td>
            </tr>
          </table>

            </p3>
            
            

			<p2 class="tab"> Functional vs Imperative</p2>
			<p class="tab"> The functional languages that we showcase on this site are list-comprehension based languages, and therefore have a strong catalogue of prewritten procedures that come in handy for this structure, however, Python is also well-equipped in that manner.Haskell, with the use of pattern matching and its "data type" feature, makes queues straightforward to implement. However, Racket is unexpectedly not a good choice for this data structure seeing as it's implementation of lists requires O(n) time to access the last index. Racket does include a data structure called a vector, which functions like an array in other languages, but it doesn't have all of the pre-written functions that lists do. All in all, Python seems to have an edge in this scenario as well. The entire data structure is well-encapsulated within its own class, and has a constant time complexity for all of the functions listed here.<br/><br/></p>
			<p2 class="tab">Static vs Dynamic</p2>
			<p class="tab">  . Obviously, Racket is not the optimal language to implement stacks in due to it's overly large time complexity for dequeue and peek, and it's dynamic typing makes it slightly unwieldier than Haskell in that way. Between the two other languages,  which have the same Big O of O(1), deciding which language is better suited for queues comes down to the use of the queues. If the queue is being used to store various types of data, Python would be a better fit, however that is always the case when writing data structures in the languages we've laid out here.<br/></p>
           <p4 class="tab"> View More DS: <a href="/BST">Queues</a>, <a href="/Linkedlist"> Linklist</a>, <a href="/Stacks"> Binary Search Tree</a><br/>
              <p4 class= "tab"><a href="/#"> Back to Main </a> </p4>
		</div>
	</body>
</html>

